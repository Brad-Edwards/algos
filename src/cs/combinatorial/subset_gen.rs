/// Module for generating the power set (all subsets) of a slice using binary representation.
///
/// This module provides:
/// - An eager function `power_set` that returns all subsets as a Vec<Vec<T>>.
/// - A lazy iterator `PowerSet` (with helper function `power_set_iter`) that yields subsets one by one.
///
/// The subsets are generated by interpreting the numbers 0..2ⁿ as bit masks, where the i‑th bit
/// indicates whether the i‑th element is included.
///
/// # Examples
///
/// Eager usage:
///
/// ```
/// use algos::cs::combinatorial::subset_gen::power_set;
///
/// let items = vec![1, 2, 3];
/// let subsets = power_set(&items);
/// // For 3 elements, there are 2^3 = 8 subsets.
/// assert_eq!(subsets.len(), 8);
/// assert!(subsets.contains(&vec![]));
/// assert!(subsets.contains(&vec![1, 2, 3]));
/// ```
///
/// Lazy usage:
///
/// ```
/// use algos::cs::combinatorial::subset_gen::power_set_iter;
///
/// let items = vec!['a', 'b'];
/// let subsets: Vec<_> = power_set_iter(&items).collect();
/// assert_eq!(subsets.len(), 4);
/// assert!(subsets.contains(&vec![]));
/// assert!(subsets.contains(&vec!['a', 'b']));
/// ```

/// Returns the power set of `elements` as a vector of subsets.
///
/// # Complexity
///
/// This function generates 2ⁿ subsets (where n is the number of elements) and each subset is built
/// in O(n) time, for an overall time complexity of O(n·2ⁿ).
pub fn power_set<T: Clone>(elements: &[T]) -> Vec<Vec<T>> {
    power_set_iter(elements).collect()
}

/// Returns an iterator over all subsets (the power set) of `elements`.
pub fn power_set_iter<T: Clone>(elements: &[T]) -> PowerSet<T> {
    let n = elements.len();
    let total = 1 << n; // 2ⁿ total subsets
    PowerSet {
        elements,
        current: 0,
        total,
    }
}

/// An iterator over the power set of a slice.
///
/// Each call to `next()` returns one subset (as a Vec<T>) corresponding to the current binary mask.
pub struct PowerSet<'a, T: Clone> {
    elements: &'a [T],
    current: usize,
    total: usize,
}

impl<'a, T: Clone> Iterator for PowerSet<'a, T> {
    type Item = Vec<T>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.total {
            let mut subset = Vec::with_capacity(self.elements.len());
            let mut mask = self.current;
            let mut index = 0;
            while index < self.elements.len() {
                if mask & 1 == 1 {
                    subset.push(self.elements[index].clone());
                }
                mask >>= 1;
                index += 1;
            }
            self.current += 1;
            Some(subset)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_slice() {
        let items: Vec<i32> = vec![];
        let subsets = power_set(&items);
        // The power set of an empty slice is a vector with one element: the empty subset.
        assert_eq!(subsets.len(), 1);
        assert_eq!(subsets[0], vec![]);
    }

    #[test]
    fn test_single_element() {
        let items = vec![42];
        let subsets = power_set(&items);
        // For one element, the power set should have 2 subsets: [] and [42].
        assert_eq!(subsets.len(), 2);
        assert!(subsets.contains(&vec![]));
        assert!(subsets.contains(&vec![42]));
    }

    #[test]
    fn test_three_elements() {
        let items = vec![1, 2, 3];
        let subsets = power_set(&items);
        // There should be 2^3 = 8 subsets.
        assert_eq!(subsets.len(), 8);
        let expected_subsets = vec![
            vec![],
            vec![1],
            vec![2],
            vec![1, 2],
            vec![3],
            vec![1, 3],
            vec![2, 3],
            vec![1, 2, 3],
        ];
        for expected in expected_subsets {
            assert!(subsets.contains(&expected), "Missing subset: {:?}", expected);
        }
    }

    #[test]
    fn test_iterator_equivalence() {
        let items = vec!['a', 'b', 'c'];
        let eager = power_set(&items);
        let lazy: Vec<_> = power_set_iter(&items).collect();
        assert_eq!(eager, lazy);
    }
} 
/// A DEFLATE-like compressor/decompressor in modern Rust.
///
/// This reference implementation combines a simple LZ77 token generator with a fixed
/// bit-encoding scheme. It is not RFC1951–compatible; rather, it uses a fixed 2‑bit tag
/// before each token to indicate its type:
///
/// - Tag 00: Literal token (followed by 8 bits for the literal).
/// - Tag 01: Length–Distance token (followed by 4 bits for (length-3) and 3 bits for (distance-1)).
/// - Tag 10: End-of-Block token (no extra bits).
///
/// The LZ77 token generator uses a small sliding window (32 bytes) and supports matches of
/// length 3–10 and distances 1–8.
pub mod algorithm {
    /// DEFLATE tokens generated by our LZ77 matching.
    #[derive(Debug, Clone)]
    pub enum Token {
        /// A literal byte.
        Literal(u8),
        /// A length–distance pair representing a match.
        LengthDistance { length: usize, distance: usize },
        /// End-of-Block marker.
        EndOfBlock,
    }

    /// Generate tokens from input using a simple LZ77 algorithm.
    ///
    /// Uses a fixed window of 32 bytes and a minimum match length of 3.
    /// Only matches with length 3–10 and distance 1–8 are supported.
    pub fn generate_tokens(input: &[u8]) -> Vec<Token> {
        let window_size = 32; // For simplicity.
        let mut tokens = Vec::new();
        let mut i = 0;
        while i < input.len() {
            let end = input.len();
            let start_window = i.saturating_sub(window_size);
            let mut best_length = 0;
            let mut best_distance = 0;
            // Search for the longest match in the window.
            for j in start_window..i {
                let mut length = 0;
                while i + length < end
                    && j + length < i
                    && length < 10  // only support up to length 10
                    && input[j + length] == input[i + length]
                {
                    length += 1;
                }
                if length > best_length && length >= 3 {
                    best_length = length;
                    best_distance = i - j;
                }
            }
            if best_length >= 3 && (1..=8).contains(&best_distance) {
                tokens.push(Token::LengthDistance {
                    length: best_length,
                    distance: best_distance,
                });
                i += best_length;
            } else {
                tokens.push(Token::Literal(input[i]));
                i += 1;
            }
        }
        tokens.push(Token::EndOfBlock);
        tokens
    }

    // --- Bit I/O Helpers ---

    /// A simple BitWriter that writes bits into a Vec<u8>.
    struct BitWriter {
        buffer: Vec<u8>,
        current_byte: u8,
        bits_filled: u8,
    }

    impl BitWriter {
        fn new() -> Self {
            BitWriter {
                buffer: Vec::new(),
                current_byte: 0,
                bits_filled: 0,
            }
        }

        /// Write the lowest `count` bits of `bits` (count ≤ 32).
        fn write_bits(&mut self, bits: u32, count: u8) {
            if count == 0 {
                return;
            }
            
            // Work with a copy of the bits
            let mut bits_remaining = count;
            let value = bits;
            
            while bits_remaining > 0 {
                // How many bits can we fit in the current byte?
                let bits_available = 8 - self.bits_filled;
                let bits_to_write = bits_available.min(bits_remaining);
                
                // Extract only the bits we need from the value
                // We want the top bits_to_write bits from value
                let mask = (1u32.wrapping_shl(bits_to_write as u32)).wrapping_sub(1);
                let extract_shift = bits_remaining.wrapping_sub(bits_to_write);
                
                // This safely extracts the bits without overflow
                let mut extracted_bits = 0u8;
                if extract_shift < 32 {  // Guard against large shifts
                    extracted_bits = ((value >> extract_shift) & mask) as u8;
                }
                
                // Position these bits correctly in the current byte
                // We need to place them at position (8 - self.bits_filled - bits_to_write)
                // but we'll use masks instead of shifts to avoid overflow
                let position = bits_available - bits_to_write;
                
                // Create a mask and place the bits
                if position == 0 {
                    // Bits go at the lowest position, no shift needed
                    self.current_byte |= extracted_bits;
                } else {
                    // We know position is in range 0..7, so this is safe
                    let positioned_bits = match position {
                        1 => extracted_bits * 2,
                        2 => extracted_bits * 4,
                        3 => extracted_bits * 8,
                        4 => extracted_bits * 16,
                        5 => extracted_bits * 32,
                        6 => extracted_bits * 64,
                        7 => extracted_bits * 128,
                        _ => 0, // Unreachable
                    };
                    self.current_byte |= positioned_bits;
                }
                
                // Update counters
                self.bits_filled += bits_to_write;
                bits_remaining -= bits_to_write;
                
                // Flush the byte if it's full
                if self.bits_filled == 8 {
                    self.buffer.push(self.current_byte);
                    self.current_byte = 0;
                    self.bits_filled = 0;
                }
            }
        }

        fn finish(mut self) -> Vec<u8> {
            // Push any partially filled byte
            if self.bits_filled > 0 {
                self.buffer.push(self.current_byte);
            }
            self.buffer
        }
    }

    /// A simple BitReader that reads bits from a Vec<u8>.
    struct BitReader {
        data: Vec<u8>,
        pos: usize,
        current_byte: u8,
        bits_left: u8,
    }

    impl BitReader {
        fn new(data: Vec<u8>) -> Self {
            let mut br = BitReader {
                data,
                pos: 0,
                current_byte: 0,
                bits_left: 0,
            };
            br.fill_byte();
            br
        }

        fn fill_byte(&mut self) {
            if self.pos < self.data.len() {
                self.current_byte = self.data[self.pos];
                self.pos += 1;
                self.bits_left = 8;
            } else {
                self.bits_left = 0;
            }
        }

        /// Read the lowest `count` bits from the current byte.
        fn read_bits(&mut self, count: u8) -> u32 {
            let mut result = 0u32;
            let mut remaining = count;
            while remaining > 0 {
                if self.bits_left == 0 {
                    self.fill_byte();
                    if self.bits_left == 0 {
                        break;
                    }
                }
                let to_take = remaining.min(self.bits_left);
                let shift = self.bits_left - to_take;
                
                // Use wider type and wrapping operations for the mask
                let mask = (1u16.wrapping_shl(to_take as u32)).wrapping_sub(1) as u8;
                let bits = (self.current_byte >> shift) & mask;
                
                result = (result << to_take) | bits as u32;
                self.bits_left -= to_take;
                remaining -= to_take;
                
                // Use the same approach for clearing remaining bits
                if self.bits_left > 0 {
                    let mask = (1u16.wrapping_shl(self.bits_left as u32)).wrapping_sub(1) as u8;
                    self.current_byte &= mask;
                } else {
                    self.current_byte = 0;
                }
            }
            result
        }
    }

    // --- DEFLATE Compression (Fixed Block with 2-bit Tag Encoding) ---
    //
    // Encoding:
    //   - Tag 00: Literal token; followed by 8 bits for the literal.
    //   - Tag 01: Length–Distance token; followed by 4 bits for (length - 3)
    //             and 3 bits for (distance - 1). (Supports lengths 3–10 and distances 1–8.)
    //   - Tag 10: End-of-Block.
    pub fn deflate_compress(input: &[u8]) -> Vec<u8> {
        let tokens = generate_tokens(input);
        let mut bw = BitWriter::new();
        for token in tokens {
            match token {
                Token::Literal(b) => {
                    // Write tag 00.
                    bw.write_bits(0b00, 2);
                    // Write literal byte (8 bits).
                    bw.write_bits(b as u32, 8);
                }
                Token::LengthDistance { length, distance } => {
                    // Write tag 01.
                    bw.write_bits(0b01, 2);
                    // Write (length - 3) in 4 bits.
                    let len_val = (length - 3) as u32;
                    bw.write_bits(len_val, 4);
                    // Write (distance - 1) in 3 bits.
                    let dist_val = (distance - 1) as u32;
                    bw.write_bits(dist_val, 3);
                }
                Token::EndOfBlock => {
                    // Write tag 10.
                    bw.write_bits(0b10, 2);
                }
            }
        }
        bw.finish()
    }

    // --- DEFLATE Decompression (Fixed Block with 2-bit Tag Encoding) ---
    pub fn deflate_decompress(compressed: &[u8]) -> Vec<u8> {
        let mut br = BitReader::new(compressed.to_vec());
        let mut output = Vec::new();
        loop {
            let tag = br.read_bits(2);
            match tag {
                0b00 => {
                    // Literal: read 8 bits.
                    let literal = br.read_bits(8) as u8;
                    output.push(literal);
                }
                0b01 => {
                    // Length-Distance: read 4 bits for (length-3), 3 bits for (distance-1).
                    let len_val = br.read_bits(4);
                    let distance_val = br.read_bits(3);
                    let length = (len_val as usize) + 3;
                    let distance = (distance_val as usize) + 1;
                    let start = output.len().saturating_sub(distance);
                    for i in 0..length {
                        output.push(output[start + i]);
                    }
                }
                0b10 => {
                    // End-of-Block.
                    break;
                }
                _ => {
                    // Reserved tag (11) is not used.
                    break;
                }
            }
        }
        output
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_deflate_no_compression() {
            // A string with little repetition; mostly literal tokens.
            let input = b"Hello, DEFLATE!";
            let compressed = deflate_compress(input);
            let decompressed = deflate_decompress(&compressed);
            assert_eq!(decompressed, input);
        }

        #[test]
        fn test_deflate_compression() {
            let input = b"abracadabra abracadabra abracadabra";
            let compressed = deflate_compress(input);
            let decompressed = deflate_decompress(&compressed);
            assert_eq!(decompressed, input);
        }

        #[test]
        fn test_token_generation() {
            // Verify that generate_tokens produces at least one length token when repetition exists.
            let input = b"aaabbb";
            let tokens = generate_tokens(input);
            let has_match = tokens.iter().any(|t| matches!(t, Token::LengthDistance { .. }));
            assert!(has_match || tokens.len() == input.len() + 1);
        }
    }
}
